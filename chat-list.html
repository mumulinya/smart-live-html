<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  <title>æ™ºè¯„ç”Ÿæ´» - èŠå¤©</title>
  <link rel="stylesheet" href="./css/element.css">
  <link href="./css/main.css" rel="stylesheet">

  <style type="text/css">
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      border-bottom: 1px solid #eee;
      background-color: #fff;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .header-back-btn {
      font-size: 20px;
      color: #333;
    }
    .header-title {
      font-size: 18px;
      font-weight: bold;
      flex: 1;
      text-align: center;
    }
    .header-search {
      font-size: 20px;
      color: #333;
    }
    .chat-list {
      height: calc(100vh - 110px);
      overflow-y: auto;
      background-color: #fff;
    }
    .chat-item {
      padding: 12px 15px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .chat-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 12px;
      background-color: #f0f0f0;
    }
    .chat-info {
      flex: 1;
      overflow: hidden;
    }
    .chat-name {
      font-weight: bold;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .chat-last-message {
      color: #666;
      font-size: 0.9em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .chat-time {
      color: #999;
      font-size: 0.8em;
      min-width: 50px;
      text-align: right;
    }
    .unread-badge {
      background-color: #f63;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 0.7em;
      position: absolute;
      top: 5px;
      right: 5px;
    }

    .global-loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      font-size: 16px;
      color: #666;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #ff6633;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 12px;
      font-size: 14px;
      color: #999;
    }

    .refresh-loading {
      position: sticky;
      top: 60px;
      background: #fff;
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #f0f0f0;
      z-index: 100;
      font-size: 14px;
      color: #666;
    }

    .refresh-loading .el-icon-loading {
      margin-right: 8px;
      color: #ff6633;
    }

    .empty-comments {
      text-align: center;
      padding: 60px 20px;
      color: #999;
    }

    .empty-comments i {
      font-size: 48px;
      margin-bottom: 16px;
      color: #ddd;
    }

    .loading {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 14px;
    }

    .no-more {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 14px;
    }

    .connection-status {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      background: #ff9800;
      color: white;
      text-align: center;
      padding: 8px;
      font-size: 14px;
      z-index: 1000;
    }
    .connection-status.connected {
      background: #07c160;
    }
    .connection-status.error {
      background: #f56c6c;
    }
  </style>
</head>
<body>
<div id="app">
  <div class="global-loading" v-if="pageLoading">
    <div class="loading-spinner"></div>
    <div class="loading-text">{{loadingText}}</div>
  </div>

  <div class="connection-status" :class="wsStatus" v-if="showConnectionStatus">
    {{connectionStatusText}}
  </div>

  <div class="refresh-loading" v-if="refreshLoading && !pageLoading">
    <i class="el-icon-loading"></i> {{loadingText}}
  </div>

  <div class="header">
    <div class="header-back-btn" style="visibility: hidden;"><i class="el-icon-arrow-left"></i></div>
    <div class="header-title">èŠå¤©</div>
    <div class="header-search" @click="search">
      <i class="el-icon-search"></i>
    </div>
  </div>

  <div class="chat-list" ref="chatList" @scroll="handleScroll">
    <div v-if="userSessionList.length === 0 && !loading" class="empty-comments">
      <i class="el-icon-chat-round"></i>
      <div>æš‚æ— èŠå¤©è®°å½•ï¼Œå¼€å§‹æ–°çš„å¯¹è¯å§ï½</div>
    </div>

    <div class="chat-item" v-for="chat in userSessionList" :key="chat.id" @click="toChat(chat.sessionId)">
      <div style="position: relative;">
        <img :src="chat.avatar || 'https://bailian-bmp-pre.oss-cn-hangzhou.aliyuncs.com/public/system_agent/PlaceHolder.png'" :alt="chat.nickName" class="chat-avatar">
        <div class="unread-badge" v-if="chat.unread > 0">{{chat.unread > 9 ? '9+' : chat.unread}}</div>
      </div>
      <div class="chat-info">
        <div class="chat-name">{{chat.nickname || 'æœªçŸ¥ç”¨æˆ·'}}</div>
        <div class="chat-last-message">{{chat.lastMessage || 'æš‚æ— æ¶ˆæ¯'}}</div>
      </div>
      <div class="chat-time">{{formatTime(chat.lastTime)}}</div>
    </div>

    <div v-if="loading" class="loading">
      <i class="el-icon-loading"></i> åŠ è½½ä¸­...
    </div>

    <div v-if="noMore" class="no-more">
      æ²¡æœ‰æ›´å¤šèŠå¤©è®°å½•äº†
    </div>
  </div>

  <foot-bar :active-btn="3"></foot-bar>
</div>

<script src="./js/vue.js"></script>
<script src="./js/axios.min.js"></script>
<script src="./js/element.js"></script>
<script src="./js/common.js"></script>
<script src="./js/footer.js"></script>
<script>
  // WebSocket ç®¡ç†ç±»ï¼ˆä¸ç§èŠé¡µé¢ç›¸åŒï¼‰
  class ChatWebSocket {
    constructor() {
      this.ws = null;
      this.isConnected = false;
      this.isAuthenticated = false;
      this.reconnectTimer = null;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 5;
      this.token = null;
      this.messageCallbacks = [];
      this.connectionCallbacks = [];
      this.authCallbacks = [];
    }

    connect(token) {
      this.token = token;

      if (this.ws) {
        this.disconnect();
      }

      const wsUrl = `ws://localhost:8888/ws`;
      console.log('ğŸ”— æ¶ˆæ¯åˆ—è¡¨è¿æ¥WebSocket:', wsUrl);

      try {
        this.ws = new WebSocket(wsUrl);

        this.ws.onopen = () => {
          console.log('âœ… æ¶ˆæ¯åˆ—è¡¨WebSocketè¿æ¥æˆåŠŸ');
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.notifyConnectionCallbacks('connected');
          this.sendAuthMessage();
        };

        this.ws.onmessage = (event) => {
          console.log('ğŸ“¨ æ¶ˆæ¯åˆ—è¡¨æ”¶åˆ°æ¶ˆæ¯:', event.data);
          try {
            const message = JSON.parse(event.data);
            this.handleServerMessage(message);
          } catch (error) {
            console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
          }
        };

        this.ws.onclose = (event) => {
          console.log('ğŸ”Œ æ¶ˆæ¯åˆ—è¡¨WebSocketè¿æ¥å…³é—­:', event.code, event.reason);
          this.isConnected = false;
          this.isAuthenticated = false;
          this.notifyConnectionCallbacks('disconnected');
          this.notifyAuthCallbacks('disconnected');
          this.tryReconnect();
        };

        this.ws.onerror = (error) => {
          console.error('âŒ æ¶ˆæ¯åˆ—è¡¨WebSocketé”™è¯¯:', error);
          this.notifyConnectionCallbacks('error');
        };

      } catch (error) {
        console.error('åˆ›å»ºWebSocketè¿æ¥å¤±è´¥:', error);
      }
    }

    sendAuthMessage() {
      if (this.token && this.isConnected) {
        const authMessage = {
          type: 'AUTH',
          data: { token: this.token },
          timestamp: Date.now()
        };
        this.ws.send(JSON.stringify(authMessage));
        console.log('ğŸ” æ¶ˆæ¯åˆ—è¡¨å‘é€è®¤è¯æ¶ˆæ¯');
      }
    }

    handleServerMessage(message) {
      switch (message.type) {
        case 'AUTH_SUCCESS':
          console.log('âœ… æ¶ˆæ¯åˆ—è¡¨èº«ä»½è®¤è¯æˆåŠŸ');
          this.isAuthenticated = true;
          this.notifyAuthCallbacks('success', message.data);
          break;
        case 'AUTH_FAILED':
          console.error('âŒ æ¶ˆæ¯åˆ—è¡¨èº«ä»½è®¤è¯å¤±è´¥:', message.data);
          this.isAuthenticated = false;
          this.notifyAuthCallbacks('failed', message.data);
          break;
        case 'NEW_MESSAGE':
          this.notifyMessageCallbacks(message);
          break;
        case 'MESSAGE_SENT':
          this.notifyMessageCallbacks(message);
          break;
        case 'SYSTEM_MESSAGE':
          this.notifyMessageCallbacks(message);
          break;
        case 'PONG':
          console.log('â¤ï¸ æ¶ˆæ¯åˆ—è¡¨æ”¶åˆ°å¿ƒè·³å›å¤');
          break;
        default:
          console.log('æ¶ˆæ¯åˆ—è¡¨æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
      }
    }

    sendMessage(type, data) {
      if (this.ws && this.isConnected) {
        const message = { type, data, timestamp: Date.now() };
        this.ws.send(JSON.stringify(message));
        console.log('ğŸ“¤ æ¶ˆæ¯åˆ—è¡¨å‘é€æ¶ˆæ¯:', message);
        return true;
      } else {
        console.error('âŒ æ¶ˆæ¯åˆ—è¡¨WebSocketæœªè¿æ¥æˆ–æœªè®¤è¯');
        return false;
      }
    }

    disconnect() {
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      this.isConnected = false;
      this.isAuthenticated = false;
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
      }
    }

    tryReconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts && this.token) {
        this.reconnectAttempts++;
        const delay = Math.min(3000 * this.reconnectAttempts, 30000);
        console.log(`æ¶ˆæ¯åˆ—è¡¨${delay/1000}ç§’åå°è¯•é‡è¿... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        this.reconnectTimer = setTimeout(() => this.connect(this.token), delay);
      } else {
        console.error('æ¶ˆæ¯åˆ—è¡¨è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿');
        this.notifyConnectionCallbacks('failed');
      }
    }

    onMessage(callback) { this.messageCallbacks.push(callback); }
    onConnectionChange(callback) { this.connectionCallbacks.push(callback); }
    onAuthChange(callback) { this.authCallbacks.push(callback); }

    notifyMessageCallbacks(message) {
      this.messageCallbacks.forEach(callback => {
        try { callback(message); } catch (error) { console.error('æ¶ˆæ¯åˆ—è¡¨æ¶ˆæ¯å›è°ƒæ‰§è¡Œé”™è¯¯:', error); }
      });
    }

    notifyConnectionCallbacks(status) {
      this.connectionCallbacks.forEach(callback => {
        try { callback(status); } catch (error) { console.error('æ¶ˆæ¯åˆ—è¡¨è¿æ¥çŠ¶æ€å›è°ƒæ‰§è¡Œé”™è¯¯:', error); }
      });
    }

    notifyAuthCallbacks(status, data) {
      this.authCallbacks.forEach(callback => {
        try { callback(status, data); } catch (error) { console.error('æ¶ˆæ¯åˆ—è¡¨è®¤è¯çŠ¶æ€å›è°ƒæ‰§è¡Œé”™è¯¯:', error); }
      });
    }
  }

  // å…¨å±€ WebSocket ç®¡ç†å™¨
  class GlobalWebSocketManager {
    constructor() {
      this.chatWebSocket = null;
      this.messageCallbacks = new Map();
    }

    init(token) {
      if (!this.chatWebSocket) {
        this.chatWebSocket = new ChatWebSocket();
      }
      if (token && (!this.chatWebSocket.isConnected || this.chatWebSocket.token !== token)) {
        this.chatWebSocket.connect(token);
        this.chatWebSocket.onMessage((message) => this.dispatchMessage(message));
      }
      return this.chatWebSocket;
    }

    getWebSocket() { return this.chatWebSocket; }
    registerCallback(namespace, callback) { this.messageCallbacks.set(namespace, callback); }
    unregisterCallback(namespace) { this.messageCallbacks.delete(namespace); }

    dispatchMessage(message) {
      this.messageCallbacks.forEach((callback, namespace) => {
        try { callback(message); } catch (error) { console.error(`æ¶ˆæ¯åˆ—è¡¨æ¶ˆæ¯å›è°ƒæ‰§è¡Œé”™è¯¯ [${namespace}]:`, error); }
      });
    }

    sendMessage(type, data) {
      return this.chatWebSocket ? this.chatWebSocket.sendMessage(type, data) : false;
    }
  }

  // åˆ›å»ºå…¨å±€å®ä¾‹
  window.globalWsManager = new GlobalWebSocketManager();

  const app = new Vue({
    el: "#app",
    data: {
      loading: false,
      noMore: false,
      current: 1,
      user: {},
      userSessionList: [],
      token: sessionStorage.getItem("token") || '',
      pageLoading: false,
      refreshLoading: false,
      firstLoad: true,
      loadingText: 'æ­£åœ¨åŠ è½½...',
      wsStatus: 'disconnected',
      showConnectionStatus: false,
      connectionStatusText: 'è¿æ¥ä¸­...'
    },
    created() {
      this.isLogin();
    },
    beforeDestroy() {
      window.globalWsManager.unregisterCallback('chat-list');
    },
    methods: {
      isLogin(){
        if (!this.token) {
          this.$message({
            type: 'warning',
            message: 'è¯·å…ˆç™»å½•',
            duration: 1000,
            onClose: () => {
              location.href = "login.html";
            }
          });
          return ;
        }else {
          this.handlePageRefresh();
          this.queryLoginUser();
        }
      },
      initWebSocket() {
        const token = this.getToken();
        if (!token) {
          console.error('æœªæ‰¾åˆ° token');
          return;
        }

        console.log('ğŸ” æ¶ˆæ¯åˆ—è¡¨é¡µé¢åˆå§‹åŒ–WebSocketè¿æ¥');
        const chatWebSocket = window.globalWsManager.init(token);

        chatWebSocket.onConnectionChange((status) => {
          console.log('ğŸ”” æ¶ˆæ¯åˆ—è¡¨è¿æ¥çŠ¶æ€å˜åŒ–:', status);
          this.handleConnectionStatusChange(status);
        });

        chatWebSocket.onAuthChange((status, data) => this.handleAuthStatusChange(status, data));

        // ğŸ”¥ å…³é”®ï¼šæ³¨å†Œæ¶ˆæ¯åˆ—è¡¨çš„å›è°ƒï¼Œå¤„ç† NEW_MESSAGE
        window.globalWsManager.registerCallback('chat-list', (message) => {
          console.log('ğŸ“¨ æ¶ˆæ¯åˆ—è¡¨å›è°ƒæ”¶åˆ°æ¶ˆæ¯:', {
            type: message.type,
            data: message.data
          });
          this.handleWebSocketMessage(message);
        });

        this.updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');

        setTimeout(() => {
          if (!chatWebSocket.isConnected) {
            console.log('â³ WebSocketè¿æ¥ç¨æ…¢ï¼Œè¯·è€å¿ƒç­‰å¾…...');
          }
        }, 2000);
      },

      // ğŸ”¥ å…³é”®ï¼šå¤„ç† WebSocket æ¶ˆæ¯
      handleWebSocketMessage(message) {
        console.log('ğŸ”” æ¶ˆæ¯åˆ—è¡¨å¤„ç†WebSocketæ¶ˆæ¯:', message.type);

        switch (message.type) {
          case 'NEW_MESSAGE':
            console.log('ğŸ’¬ æ”¶åˆ°æ–°æ¶ˆæ¯ï¼Œæ›´æ–°æ¶ˆæ¯åˆ—è¡¨');
            this.handleNewMessage(message.data);
            break;
          case 'MESSAGE_SENT':
            console.log('âœ… æ¶ˆæ¯å‘é€æˆåŠŸï¼ˆåœ¨æ¶ˆæ¯åˆ—è¡¨é¡µé¢å¿½ç•¥ï¼‰');
            break;
          case 'SYSTEM_MESSAGE':
            console.log('â„¹ï¸ ç³»ç»Ÿæ¶ˆæ¯:', message.data);
            if (message.data && message.data.content) {
              this.$message.info(message.data.content);
            }
            break;
          default:
            console.log('â“ æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
        }
      },

      // ğŸ”¥ å…³é”®ï¼šå¤„ç†æ–°æ¶ˆæ¯ï¼Œæ›´æ–°æ¶ˆæ¯åˆ—è¡¨
      handleNewMessage(messageData) {
        console.log('ğŸ’¬ å¤„ç†æ–°æ¶ˆæ¯æ•°æ®:', messageData);

        // éªŒè¯å¿…è¦å­—æ®µ
        if (!messageData.sessionId) {
          console.error('âŒ æ–°æ¶ˆæ¯ç¼ºå°‘sessionIdï¼Œæ— æ³•æ›´æ–°åˆ—è¡¨');
          return;
        }

        const sessionId = messageData.sessionId;
        const fromUid = messageData.fromUid;
        const currentUserId = this.user.id;

        console.log('ğŸ” æ¶ˆæ¯è¯¦æƒ…:', {
          sessionId: sessionId,
          æ¶ˆæ¯æ¥è‡ª: fromUid,
          å½“å‰ç”¨æˆ·: currentUserId,
          æ˜¯å¦è‡ªå·±å‘é€: fromUid === currentUserId
        });

        // æŸ¥æ‰¾ç°æœ‰ä¼šè¯
        const sessionIndex = this.userSessionList.findIndex(
                session => session.sessionId == sessionId
        );

        if (sessionIndex !== -1) {
          console.log('âœ… æ‰¾åˆ°ç°æœ‰ä¼šè¯ï¼Œç´¢å¼•:', sessionIndex);
          const session = this.userSessionList[sessionIndex];

          // å¦‚æœæ¶ˆæ¯ä¸æ˜¯å½“å‰ç”¨æˆ·å‘é€çš„ï¼Œå¢åŠ æœªè¯»æ•°
          if (fromUid !== currentUserId) {
            session.unread = (session.unread || 0) + 1;
            console.log('ğŸ”´ å¢åŠ æœªè¯»è®¡æ•°:', session.unread);
          } else {
            console.log('âœ… æ¶ˆæ¯æ¥è‡ªè‡ªå·±ï¼Œä¸å¢åŠ æœªè¯»è®¡æ•°');
          }

          // æ›´æ–°æœ€åæ¶ˆæ¯å’Œæ—¶é—´
          session.lastMessage = messageData.content || 'æ–°æ¶ˆæ¯';
          session.lastTime = messageData.createTime || new Date().toISOString();

          console.log('ğŸ“ æ›´æ–°ä¼šè¯å†…å®¹:', {
            lastMessage: session.lastMessage,
            lastTime: session.lastTime,
            unread: session.unread
          });

          // å°†æ›´æ–°çš„ä¼šè¯ç§»åˆ°æœ€å‰é¢
          const updatedSession = this.userSessionList.splice(sessionIndex, 1)[0];
          this.userSessionList.unshift(updatedSession);

          console.log('âœ… æ¶ˆæ¯åˆ—è¡¨å·²æ›´æ–°ï¼Œä¼šè¯ç§»åˆ°æœ€å‰é¢');

        } else {
          console.log('ğŸ†• æ”¶åˆ°æ–°ä¼šè¯æ¶ˆæ¯ï¼Œé‡æ–°åŠ è½½åˆ—è¡¨');
          // å¯¹äºæ–°ä¼šè¯ï¼Œé‡æ–°åŠ è½½åˆ—è¡¨è·å–å®Œæ•´ä¿¡æ¯
          this.refreshList();
        }
      },

      handleConnectionStatusChange(status) {
        switch (status) {
          case 'connected':
            this.updateConnectionStatus('connected', 'è¿æ¥æˆåŠŸ', 2000);
            console.log('ğŸ‰ æ¶ˆæ¯åˆ—è¡¨WebSocketè¿æ¥æˆåŠŸï¼Œå¯ä»¥æ¥æ”¶å®æ—¶æ›´æ–°');
            break;
          case 'disconnected': this.updateConnectionStatus('disconnected', 'è¿æ¥æ–­å¼€'); break;
          case 'error': this.updateConnectionStatus('error', 'è¿æ¥é”™è¯¯'); break;
          case 'failed': this.updateConnectionStatus('error', 'è¿æ¥å¤±è´¥'); break;
        }
      },

      handleAuthStatusChange(status, data) {
        if (status === 'success') {
          console.log('âœ… æ¶ˆæ¯åˆ—è¡¨ç”¨æˆ·è®¤è¯æˆåŠŸï¼Œå¯ä»¥æ¥æ”¶æ¶ˆæ¯');
        } else {
          console.error('âŒ æ¶ˆæ¯åˆ—è¡¨è®¤è¯å¤±è´¥:', data);
        }
      },

      updateConnectionStatus(status, text, autoHide = null) {
        this.wsStatus = status;
        this.connectionStatusText = text;
        this.showConnectionStatus = true;
        if (autoHide && status === 'connected') {
          setTimeout(() => this.showConnectionStatus = false, autoHide);
        }
      },

      getToken() {
        return sessionStorage.getItem('token');
      },

      showPageLoading(text = 'æ­£åœ¨åŠ è½½...') { this.pageLoading = true; this.loadingText = text; },
      hidePageLoading() { this.pageLoading = false; this.refreshLoading = false; },
      showRefreshLoading(text = 'æ­£åœ¨åˆ·æ–°...') { this.refreshLoading = true; this.loadingText = text; },

      handlePageRefresh() {
        if (this.firstLoad) {
          this.showPageLoading('æ­£åœ¨åŠ è½½èŠå¤©åˆ—è¡¨...');
          this.firstLoad = false;
        } else {
          this.showRefreshLoading('æ­£åœ¨åˆ·æ–°...');
        }
        setTimeout(() => this.hidePageLoading(), 800);
      },

      async queryLoginUser() {
        try {
          await axios.get("/app/user/me").then(({ data }) => this.user = data);
          this.initWebSocket();
          await this.loadUserSessionWithLoading();
        } catch (error) {
          this.$message({ type: 'warning', message: 'è¯·å…ˆç™»å½•', duration: 1000, onClose: () => location.href = "login.html" });
          this.hidePageLoading();
        }
      },

      async loadUserSessionWithLoading() {
        if (this.loading || this.noMore) return;
        if (this.userSessionList.length === 0) this.showPageLoading('æ­£åœ¨åŠ è½½èŠå¤©åˆ—è¡¨...');
        else this.showRefreshLoading('åŠ è½½æ›´å¤šèŠå¤©...');

        this.loading = true;
        try {
          const response = await axios.get('/app/chat/userSession/list', { params: { userId: this.user.id, current: this.current } });
          response.data.forEach(session => session.avatar = fileURL + session.avatar);
          const newSessions = response.data || [];

          if (newSessions.length === 0) {
            this.noMore = true;
            if (this.current === 1) this.userSessionList = [];
          } else {
            this.userSessionList = this.current === 1 ? newSessions : [...this.userSessionList, ...newSessions];
          }
        } catch (error) {
          console.error('åŠ è½½èŠå¤©åˆ—è¡¨å¤±è´¥:', error);
          this.$message.error('åŠ è½½èŠå¤©åˆ—è¡¨å¤±è´¥');
        } finally {
          this.loading = false;
          this.hidePageLoading();
        }
      },

      toChat(sessionId) { location.href = "/chat.html?sessionId=" + sessionId; },
      search() { alert('æœç´¢åŠŸèƒ½æš‚æœªå®ç°'); },

      handleScroll() {
        const container = this.$refs.chatList;
        if (!container) return;
        const { scrollTop, scrollHeight, clientHeight } = container;
        if (scrollHeight - scrollTop - clientHeight < 50 && !this.loading && !this.noMore) {
          this.current++;
          this.loadUserSessionWithLoading();
        }
      },

      formatTime(timeStr) {
        if (!timeStr) return '';
        try {
          const date = new Date(timeStr);
          const now = new Date();
          const diff = now - date;
          if (diff < 60000) return 'åˆšåˆš';
          else if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
          else if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
          else if (diff < 2592000000) return Math.floor(diff / 86400000) + 'å¤©å‰';
          else return date.getFullYear() + 'å¹´' + (date.getMonth() + 1) + 'æœˆ' + date.getDate() + 'æ—¥';
        } catch (e) { return timeStr; }
      },

      refreshList() {
        this.userSessionList = [];
        this.current = 1;
        this.noMore = false;
        this.loadUserSessionWithLoading();
      }
    }
  });
</script>
</body>
</html>