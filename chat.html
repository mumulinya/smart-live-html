<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  <title>æ™ºè¯„ç”Ÿæ´» - ç§èŠ</title>
  <link rel="stylesheet" href="./css/element.css">
  <link href="./css/main.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style type="text/css">
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 0; background-color: #f5f5f5; }
    .header { display: flex; align-items: center; justify-content: space-between; padding: 15px; border-bottom: 1px solid #e1e1e1; background-color: #f7f7f7; position: sticky; top: 0; z-index: 100; }
    .header-back-btn { font-size: 20px; color: #333; cursor: pointer; display: flex; align-items: center; }
    .header-title { font-size: 18px; font-weight: bold; flex: 1; text-align: center; }
    .chat-messages { height: calc(100vh - 210px); padding: 15px; overflow-y: auto; display: flex; flex-direction: column; background-color: #eaeaea; }
    .message-container { display: flex; margin-bottom: 15px; max-width: 100%; }
    .message-container-left { flex-direction: row; }
    .message-container-right { flex-direction: row-reverse; }
    .avatar { width: 40px; height: 40px; border-radius: 50%; margin: 0 10px; background-color: #ddd; display: flex; align-items: center; justify-content: center; color: #fff; font-weight: bold; font-size: 16px; overflow: hidden; flex-shrink: 0; }
    .avatar img { width: 100%; height: 100%; object-fit: cover; }
    .avatar-fallback { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #07c160; color: white; }
    .avatar-left .avatar-fallback { background-color: #07c160; }
    .avatar-right .avatar-fallback { background-color: #ff6633; }
    .message-content { display: flex; flex-direction: column; max-width: 70%; }
    .message { padding: 10px 15px; border-radius: 5px; word-wrap: break-word; position: relative; font-size: 16px; line-height: 1.4; }
    .message-left { background-color: #fff; border-top-left-radius: 0; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
    .message-right { background-color: #95ec69; border-top-right-radius: 0; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
    .time-separator { text-align: center; margin: 15px 0; position: relative; }
    .time-separator::before { content: ""; position: absolute; top: 50%; left: 0; right: 0; height: 1px; background-color: #e0e0e0; z-index: 1; }
    .time-label { display: inline-block; background-color: #d8d8d8; padding: 3px 10px; border-radius: 10px; font-size: 12px; color: #666; position: relative; z-index: 2; }
    .system-message { background-color: #f0f0f0; align-self: center; max-width: 80%; border-radius: 10px; margin: 5px 0; padding: 5px 10px; font-size: 12px; text-align: center; color: #999; }
    .chat-input { padding: 10px 15px; border-top: 1px solid #e1e1e1; display: flex; background-color: #f7f7f7; }
    .chat-input input { flex: 1; padding: 10px 15px; border: 1px solid #ddd; border-radius: 20px; margin-right: 10px; font-size: 16px; outline: none; }
    .chat-input button { padding: 10px 20px; background-color: #07c160; color: white; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 16px; }
    .chat-input button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
    .global-loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; font-size: 16px; color: #666; }
    .loading-spinner { width: 40px; height: 40px; border: 3px solid #f3f3f3; border-top: 3px solid #07c160; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 16px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .loading-text { margin-top: 12px; font-size: 14px; color: #999; }
    .refresh-loading { position: sticky; top: 60px; background: #fff; padding: 12px; text-align: center; border-bottom: 1px solid #f0f0f0; z-index: 100; font-size: 14px; color: #666; }
    .refresh-loading .el-icon-loading { margin-right: 8px; color: #07c160; }
    .loading { text-align: center; padding: 20px; color: #999; font-size: 14px; }
    .no-more { text-align: center; padding: 20px; color: #999; font-size: 14px; }
    .empty-messages { text-align: center; padding: 60px 20px; color: #999; }
    .empty-messages i { font-size: 48px; margin-bottom: 16px; color: #ddd; }
    .connection-status { position: fixed; top: 60px; left: 0; right: 0; background: #ff9800; color: white; text-align: center; padding: 8px; font-size: 14px; z-index: 1000; }
    .connection-status.connected { background: #07c160; }
    .connection-status.error { background: #f56c6c; }
    .message-status { font-size: 12px; color: #999; margin-top: 4px; text-align: right; }
    .message-status.sending { color: #ff9800; }
    .message-status.sent { color: #07c160; }
    .message-status.failed { color: #f56c6c; }
    .auth-status { position: fixed; top: 100px; left: 0; right: 0; background: #2196f3; color: white; text-align: center; padding: 6px; font-size: 12px; z-index: 1000; }
    .message-read-status { font-size: 10px; color: #07c160; margin-top: 2px; text-align: right; }
    .message-delivered-status { font-size: 10px; color: #999; margin-top: 2px; text-align: right; }
  </style>
</head>
<body>
<div id="app">
  <div class="global-loading" v-if="pageLoading">
    <div class="loading-spinner"></div>
    <div class="loading-text">{{loadingText}}</div>
  </div>

  <div class="connection-status" :class="wsStatus" v-if="showConnectionStatus">
    {{connectionStatusText}}
  </div>

  <div class="auth-status" v-if="showAuthStatus">
    {{authStatusText}}
  </div>

  <div class="refresh-loading" v-if="refreshLoading && !pageLoading">
    <i class="el-icon-loading"></i> {{loadingText}}
  </div>

  <div class="header">
    <div class="header-back-btn" @click="goBack">
      <i class="el-icon-arrow-left"></i>
      <span style="margin-left: 5px; font-size: 16px;"></span>
    </div>
    <div class="header-title">{{contactName}}</div>
    <div style="width: 20px;"></div>
  </div>

  <div class="chat-messages" ref="chatMessages" @scroll="handleScroll">
    <div v-if="messages.length === 0 && !loading" class="empty-messages">
      <i class="el-icon-chat-round"></i>
      <div>æš‚æ— æ¶ˆæ¯ï¼Œå¼€å§‹èŠå¤©å§ï½</div>
    </div>

    <template v-for="(msgGroup, index) in groupedMessages">
      <div v-if="msgGroup.showTime" :key="'time-' + index" class="time-separator">
        <span class="time-label">{{ formatGroupTime(msgGroup.time) }}</span>
      </div>

      <div v-for="msg in msgGroup.messages" :key="msg.id || msg.tempId"
           class="message-container"
           :class="{'message-container-left': !msg.isSelf, 'message-container-right': msg.isSelf}">

        <div class="avatar" :class="{'avatar-left': !msg.isSelf, 'avatar-right': msg.isSelf}">
          <img v-if="msg.isSelf && user.icon" class="avatar-image" :src="user.icon" :alt="user.nickname" @error="handleAvatarError">
          <img v-else-if="!msg.isSelf && contactAvatar" class="avatar-image" :src="contactAvatar" :alt="contactName" @error="handleAvatarError">
          <div v-else class="avatar-fallback">
            {{ msg.isSelf ? (user.nickname || 'æˆ‘').charAt(0) : (contactName || 'å‹').charAt(0) }}
          </div>
        </div>

        <div class="message-content">
          <div v-if="!msg.isSystem" class="message" :class="{'message-left': !msg.isSelf, 'message-right': msg.isSelf}">
            {{msg.content}}
            <!-- æ¶ˆæ¯çŠ¶æ€æ˜¾ç¤º -->
            <div v-if="msg.isSelf" class="message-status-container">
              <div class="message-status" :class="msg.status" v-if="msg.status === 'sending' || msg.status === 'failed'">
                {{getStatusText(msg.status)}}
              </div>
              <div v-else-if="msg.dbStatus === 1" class="message-read-status">å·²è¯»</div>
              <div v-else-if="msg.dbStatus === 2" class="message-delivered-status">å·²é€è¾¾</div>
              <div v-else class="message-status sent">{{getStatusText('sent')}}</div>
            </div>
          </div>
        </div>
      </div>
    </template>

    <div v-if="msg.isSystem" class="system-message" v-for="msg in systemMessages" :key="msg.id">
      {{msg.content}}
    </div>

    <div v-if="loading" class="loading">
      <i class="el-icon-loading"></i> åŠ è½½ä¸­...
    </div>
  </div>

  <div class="chat-input">
    <input type="text" v-model="messageInput" @keyup.enter="sendMessage" placeholder="è¾“å…¥æ¶ˆæ¯...">
    <button @click="sendMessage" :disabled="isSendDisabled">å‘é€</button>
  </div>

  <foot-bar :active-btn="3"></foot-bar>
</div>

<script src="./js/vue.js"></script>
<script src="./js/axios.min.js"></script>
<script src="./js/element.js"></script>
<script src="./js/common.js"></script>
<script src="./js/footer.js"></script>
<script>
  // ========== å…¨å±€ WebSocket ç±»å®šä¹‰ ==========
  // WebSocket ç®¡ç†ç±»
  class ChatWebSocket {
    constructor() {
      this.ws = null;
      this.isConnected = false;
      this.isAuthenticated = false;
      this.reconnectTimer = null;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 5;
      this.token = null;
      this.messageCallbacks = [];
      this.connectionCallbacks = [];
      this.authCallbacks = [];
    }

    connect(token,sessionId) {
      this.token = token;
      this.sessionId = sessionId;
      if (this.ws) {
        this.disconnect();
      }

      const wsUrl = `ws://localhost:8888/ws`;
      console.log('ğŸ”— ç§èŠé¡µé¢è¿æ¥WebSocket:', wsUrl);

      try {
        this.ws = new WebSocket(wsUrl);

        this.ws.onopen = () => {
          console.log('âœ… ç§èŠé¡µé¢WebSocketè¿æ¥æˆåŠŸ');
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.notifyConnectionCallbacks('connected');
          this.sendAuthMessage();
        };

        this.ws.onmessage = (event) => {
          console.log('ğŸ“¨ ç§èŠé¡µé¢æ”¶åˆ°æ¶ˆæ¯:', event.data);
          try {
            const message = JSON.parse(event.data);
            this.handleServerMessage(message);
          } catch (error) {
            console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
          }
        };

        this.ws.onclose = (event) => {
          console.log('ğŸ”Œ ç§èŠé¡µé¢WebSocketè¿æ¥å…³é—­:', event.code, event.reason);
          this.isConnected = false;
          this.isAuthenticated = false;
          this.notifyConnectionCallbacks('disconnected');
          this.notifyAuthCallbacks('disconnected');
          this.tryReconnect();
        };

        this.ws.onerror = (error) => {
          console.error('âŒ ç§èŠé¡µé¢WebSocketé”™è¯¯:', error);
          this.notifyConnectionCallbacks('error');
        };

      } catch (error) {
        console.error('åˆ›å»ºWebSocketè¿æ¥å¤±è´¥:', error);
      }
    }

    sendAuthMessage() {
      if (this.token && this.isConnected) {
        const authMessage = {
          type: 'AUTH',
          data: { token: this.token,sessionId:this.sessionId },
          timestamp: Date.now()
        };
        this.ws.send(JSON.stringify(authMessage));
        console.log('ğŸ” ç§èŠé¡µé¢å‘é€è®¤è¯æ¶ˆæ¯');
      }
    }

    handleServerMessage(message) {
      switch (message.type) {
        case 'AUTH_SUCCESS':
          console.log('âœ… ç§èŠé¡µé¢èº«ä»½è®¤è¯æˆåŠŸ');
          this.isAuthenticated = true;
          this.notifyAuthCallbacks('success', message.data);
          break;
        case 'AUTH_FAILED':
          console.error('âŒ ç§èŠé¡µé¢èº«ä»½è®¤è¯å¤±è´¥:', message.data);
          this.isAuthenticated = false;
          this.notifyAuthCallbacks('failed', message.data);
          break;
        case 'NEW_MESSAGE':
          this.notifyMessageCallbacks(message);
          break;
        case 'MESSAGE_SENT':
          this.notifyMessageCallbacks(message);
          break;
        case 'SYSTEM_MESSAGE':
          this.notifyMessageCallbacks(message);
          break;
        case 'MESSAGE_STATUS_UPDATE': // ğŸ”¥ æ–°å¢ï¼šå¤„ç†æ¶ˆæ¯çŠ¶æ€æ›´æ–°
          this.notifyMessageCallbacks(message);
          break;
        case 'PONG':
          console.log('â¤ï¸ ç§èŠé¡µé¢æ”¶åˆ°å¿ƒè·³å›å¤');
          break;
        default:
          console.log('ç§èŠé¡µé¢æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
      }
    }

    sendMessage(type, data) {
      if (this.ws && this.isConnected) {
        const message = { type, data, timestamp: Date.now() };
        this.ws.send(JSON.stringify(message));
        console.log('ğŸ“¤ ç§èŠé¡µé¢å‘é€æ¶ˆæ¯:', message);
        return true;
      } else {
        console.error('âŒ ç§èŠé¡µé¢WebSocketæœªè¿æ¥æˆ–æœªè®¤è¯');
        return false;
      }
    }

    disconnect() {
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      this.isConnected = false;
      this.isAuthenticated = false;
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
      }
    }

    tryReconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts && this.token) {
        this.reconnectAttempts++;
        const delay = Math.min(3000 * this.reconnectAttempts, 30000);
        console.log(`ç§èŠé¡µé¢${delay/1000}ç§’åå°è¯•é‡è¿... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        this.reconnectTimer = setTimeout(() => this.connect(this.token,this.sessionId), delay);
      } else {
        console.error('ç§èŠé¡µé¢è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿');
        this.notifyConnectionCallbacks('failed');
      }
    }

    onMessage(callback) { this.messageCallbacks.push(callback); }
    onConnectionChange(callback) { this.connectionCallbacks.push(callback); }
    onAuthChange(callback) { this.authCallbacks.push(callback); }

    notifyMessageCallbacks(message) {
      this.messageCallbacks.forEach(callback => {
        try { callback(message); } catch (error) { console.error('ç§èŠé¡µé¢æ¶ˆæ¯å›è°ƒæ‰§è¡Œé”™è¯¯:', error); }
      });
    }

    notifyConnectionCallbacks(status) {
      this.connectionCallbacks.forEach(callback => {
        try { callback(status); } catch (error) { console.error('ç§èŠé¡µé¢è¿æ¥çŠ¶æ€å›è°ƒæ‰§è¡Œé”™è¯¯:', error); }
      });
    }

    notifyAuthCallbacks(status, data) {
      this.authCallbacks.forEach(callback => {
        try { callback(status, data); } catch (error) { console.error('ç§èŠé¡µé¢è®¤è¯çŠ¶æ€å›è°ƒæ‰§è¡Œé”™è¯¯:', error); }
      });
    }
  }

  // å…¨å±€ WebSocket ç®¡ç†å™¨
  class GlobalWebSocketManager {
    constructor() {
      this.chatWebSocket = null;
      this.messageCallbacks = new Map();
    }

    init(token, sessionId) {
      if (!this.chatWebSocket) {
        this.chatWebSocket = new ChatWebSocket();
      }
      // åªæœ‰åœ¨æœ‰tokenä¸”æœªè¿æ¥æ—¶æ‰è¿æ¥
      if (token && (!this.chatWebSocket.isConnected || this.chatWebSocket.token !== token)) {
        this.chatWebSocket.connect(token, sessionId);
        this.chatWebSocket.onMessage((message) => this.dispatchMessage(message));
      }
      return this.chatWebSocket;
    }

    getWebSocket() { return this.chatWebSocket; }
    registerCallback(namespace, callback) { this.messageCallbacks.set(namespace, callback); }
    unregisterCallback(namespace) { this.messageCallbacks.delete(namespace); }

    dispatchMessage(message) {
      this.messageCallbacks.forEach((callback, namespace) => {
        try { callback(message); } catch (error) { console.error(`ç§èŠé¡µé¢æ¶ˆæ¯å›è°ƒæ‰§è¡Œé”™è¯¯ [${namespace}]:`, error); }
      });
    }

    sendMessage(type, data) {
      return this.chatWebSocket ? this.chatWebSocket.sendMessage(type, data) : false;
    }
  }

  // ========== å…¨å±€ç®¡ç†å™¨åˆå§‹åŒ– ==========
  // å¦‚æœå…¨å±€ç®¡ç†å™¨ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
  if (!window.globalWsManager) {
    console.log('ğŸ†• ç§èŠé¡µé¢åˆ›å»ºå…¨å±€WebSocketç®¡ç†å™¨');
    window.globalWsManager = new GlobalWebSocketManager();
  } else {
    console.log('âœ… ç§èŠé¡µé¢æ£€æµ‹åˆ°å…¨å±€WebSocketç®¡ç†å™¨å·²å­˜åœ¨');
  }

  // ========== Vue åº”ç”¨ä»£ç  ==========
  const app = new Vue({
    el: "#app",
    data: {
      sessionId: 0,
      fromUid: 0,
      toUid: 0,
      contactName: "åŠ è½½ä¸­...",
      contactAvatar: "",
      messages: [],
      messageInput: "",
      loading: false,
      noMore: false,
      current: 1,
      pageLoading: false,
      refreshLoading: false,
      firstLoad: true,
      loadingText: 'æ­£åœ¨åŠ è½½...',
      user: { id: 0, nickname: 'æˆ‘', icon: '' },
      contactUser: {},
      isSending: false,
      autoScroll: true,
      isAtBottom: true,
      wsStatus: 'disconnected',
      showConnectionStatus: false,
      connectionStatusText: 'è¿æ¥ä¸­...',
      showAuthStatus: false,
      authStatusText: 'è®¤è¯ä¸­...',
      forceEnableSend: false,
      statusCheckInterval: null
    },
    computed: {
      groupedMessages() {
        const groups = [];
        let currentGroup = null;

        const normalMessages = this.messages
                .filter(msg => !msg.isSystem)
                .sort((a, b) => new Date(a.createTime) - new Date(b.createTime));

        normalMessages.forEach(msg => {
          const groupTime = this.getGroupTime(msg.createTime);
          if (!currentGroup || currentGroup.time !== groupTime) {
            currentGroup = { time: groupTime, messages: [], showTime: true };
            groups.push(currentGroup);
          }
          currentGroup.messages.push(msg);
        });
        return groups;
      },
      systemMessages() {
        return this.messages.filter(msg => msg.isSystem);
      },
      isSendDisabled() {
        const isEmpty = !this.messageInput || this.messageInput.trim() === '';
        return isEmpty || this.isSending || (!this.forceEnableSend && !this.isWebSocketReady);
      },
      isWebSocketReady() {
        const chatWebSocket = window.globalWsManager ? window.globalWsManager.getWebSocket() : null;
        return chatWebSocket && chatWebSocket.isConnected && chatWebSocket.isAuthenticated;
      }
    },
    created() {
      this.sessionId = util.getUrlParam("sessionId");
      this.getChatSession();
      this.handlePageRefresh();
      this.queryLoginUser();

      this.statusCheckInterval = setInterval(() => {
        this.checkMessageStatus();
      }, 30000);
    },
    mounted() {
      this.scrollToBottom();

      // è®¾ç½®å½“å‰æ´»è·ƒä¼šè¯
      this.setCurrentActiveSession();
    },
    beforeDestroy() {
      // ç¦»å¼€é¡µé¢æ—¶æ¸…é™¤æ´»è·ƒä¼šè¯
      this.clearCurrentActiveSession();

      // ç§»é™¤æ¶ˆæ¯å›è°ƒ
      if (window.globalWsManager) {
        window.globalWsManager.unregisterCallback('private-chat-' + this.sessionId);
      }
      if (this.statusCheckInterval) {
        clearInterval(this.statusCheckInterval);
      }
    },
    methods: {
      // è®¾ç½®å½“å‰æ´»è·ƒä¼šè¯
      setCurrentActiveSession() {
        if (window.globalWsManager && this.sessionId) {
          window.globalWsManager.sendMessage('UPDATE_ACTIVE_SESSION', {
            sessionId: this.sessionId
          });
          console.log('ğŸ‘€ è®¾ç½®å½“å‰æ´»è·ƒä¼šè¯:', this.sessionId);
        }
      },

      // æ¸…é™¤å½“å‰æ´»è·ƒä¼šè¯
      clearCurrentActiveSession() {
        if (window.globalWsManager) {
          window.globalWsManager.sendMessage('UPDATE_ACTIVE_SESSION', {
            sessionId: null
          });
          console.log('ğŸšª æ¸…é™¤å½“å‰æ´»è·ƒä¼šè¯');
        }
      },

      checkMessageStatus() {
        const now = Date.now();
        const sendingMessages = this.messages.filter(msg =>
                msg.status === 'sending' &&
                msg.tempId &&
                now - parseInt(msg.tempId.split('_')[1]) > 10000
        );

        if (sendingMessages.length > 0) {
          console.log('å‘ç°é•¿æ—¶é—´å‘é€ä¸­çš„æ¶ˆæ¯:', sendingMessages);
          sendingMessages.forEach(msg => {
            const messageIndex = this.messages.findIndex(m => m.tempId === msg.tempId);
            if (messageIndex !== -1) {
              this.messages[messageIndex].status = 'failed';
              this.$set(this.messages, messageIndex, { ...this.messages[messageIndex] });
            }
          });
          this.$message.warning('éƒ¨åˆ†æ¶ˆæ¯å‘é€è¶…æ—¶ï¼Œè¯·é‡æ–°å‘é€');
        }
      },

      initWebSocket() {
        console.log('ğŸ”— ç§èŠé¡µé¢åˆå§‹åŒ–WebSocketè¿æ¥');
        this.createOptimizedWebSocket();
      },

      createOptimizedWebSocket() {
        const token = this.getToken();
        if (!token) {
          console.error('æœªæ‰¾åˆ°tokenï¼Œæ— æ³•åˆ›å»ºè¿æ¥');
          this.updateConnectionStatus('error', 'æœªç™»å½•');
          this.forceEnableSend = true;
          return;
        }

        console.log('ğŸ”— åˆ›å»ºä¼˜åŒ–çš„WebSocketè¿æ¥');

        // ä½¿ç”¨å…¨å±€ç®¡ç†å™¨
        if (!window.globalWsManager) {
          window.globalWsManager = new GlobalWebSocketManager();
        }
         //ä¼ å…¥ä¼šè¯id
        const chatWebSocket = window.globalWsManager.init(token,this.sessionId);

        this.setupWebSocketListeners(chatWebSocket);

        chatWebSocket.onConnectionChange((status) => {
          console.log('ğŸ”” è¿æ¥çŠ¶æ€å˜åŒ–:', status);
          this.handleConnectionStatusChange(status);
        });

        // è¿æ¥çŠ¶æ€æç¤º
        this.updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');

        setTimeout(() => {
          if (!chatWebSocket.isConnected) {
            console.log('â³ WebSocketè¿æ¥ç¨æ…¢ï¼Œè¯·è€å¿ƒç­‰å¾…...');
          }
        }, 2000);
      },

      setupWebSocketListeners(chatWebSocket) {
        // æ³¨å†Œç§èŠé¡µé¢çš„å›è°ƒ
        window.globalWsManager.registerCallback('private-chat-' + this.sessionId, (message) => {
          this.handleWebSocketMessage(message);
        });

        // æ›´æ–°è¿æ¥çŠ¶æ€
        if (chatWebSocket.isConnected) {
          this.updateConnectionStatus('connected', 'è¿æ¥æˆåŠŸ', 2000);
          // è¿æ¥æˆåŠŸåè®¾ç½®å½“å‰æ´»è·ƒä¼šè¯
          this.$nextTick(() => {
            this.setCurrentActiveSession();
          });
        } else {
          this.updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');
        }
      },

      handleConnectionStatusChange(status) {
        switch (status) {
          case 'connected':
            this.updateConnectionStatus('connected', 'è¿æ¥æˆåŠŸ', 2000);
            // è¿æ¥æˆåŠŸåè®¾ç½®å½“å‰æ´»è·ƒä¼šè¯
            this.setCurrentActiveSession();
            break;
          case 'disconnected':
            this.updateConnectionStatus('disconnected', 'è¿æ¥æ–­å¼€');
            break;
          case 'error':
            this.updateConnectionStatus('error', 'è¿æ¥é”™è¯¯');
            break;
          case 'failed':
            this.updateConnectionStatus('error', 'è¿æ¥å¤±è´¥');
            break;
        }
      },

      handleWebSocketMessage(message) {
        console.log('ğŸ”” ç§èŠé¡µé¢æ”¶åˆ°WebSocketæ¶ˆæ¯:', message);

        // é’ˆå¯¹ MESSAGE_SENT æ¶ˆæ¯ç‰¹æ®Šå¤„ç† - å®ƒå¯èƒ½æ²¡æœ‰ sessionId
        if (message.type === 'MESSAGE_SENT') {
          console.log('âœ… å¤„ç†æ¶ˆæ¯å‘é€æˆåŠŸå›è°ƒï¼Œè·³è¿‡ä¼šè¯æ£€æŸ¥');
          this.handleMessageSent(message.data);
          return;
        }

        // ğŸ”¥ æ–°å¢ï¼šå¤„ç†æ¶ˆæ¯çŠ¶æ€æ›´æ–°ï¼ˆå¦‚å·²è¯»çŠ¶æ€ï¼‰
        if (message.type === 'MESSAGE_STATUS_UPDATE') {
          console.log('ğŸ”„ å¤„ç†æ¶ˆæ¯çŠ¶æ€æ›´æ–°:', message.data);
          this.handleMessageStatusUpdate(message.data);
          return;
        }

        // å…¶ä»–æ¶ˆæ¯ç±»å‹ï¼ˆNEW_MESSAGE, SYSTEM_MESSAGEï¼‰æ‰è¿›è¡Œä¼šè¯æ£€æŸ¥
        if (message.data && message.data.sessionId != this.sessionId) {
          console.log('ğŸš« å¿½ç•¥éå½“å‰ä¼šè¯çš„æ¶ˆæ¯: æ¶ˆæ¯ä¼šè¯=' + message.data.sessionId + ', å½“å‰ä¼šè¯=' + this.sessionId);
          return;
        }

        switch (message.type) {
          case 'NEW_MESSAGE':
            console.log('ğŸ’¬ å¤„ç†æ–°æ¶ˆæ¯');
            this.handleNewMessage(message.data);
            break;
          case 'SYSTEM_MESSAGE':
            console.log('â„¹ï¸ å¤„ç†ç³»ç»Ÿæ¶ˆæ¯');
            this.handleSystemMessage(message.data);
            break;
          default:
            console.log('â“ æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
        }
      },

      // ğŸ”¥ ç»Ÿä¸€å¤„ç†æ¶ˆæ¯çŠ¶æ€æ›´æ–°
      handleMessageStatusUpdate(messageData) {
        console.log('å¤„ç†æ¶ˆæ¯çŠ¶æ€æ›´æ–°æ•°æ®:', messageData);

        // å¦‚æœæ˜¯æ‰¹é‡å·²è¯»é€šçŸ¥
        if (messageData.type === 'BATCH_MESSAGES_READ') {
          const sessionId = messageData.sessionId;
          const newStatus = messageData.status;

          console.log('ğŸ”„ æ‰¹é‡æ›´æ–°ä¼šè¯æ¶ˆæ¯çŠ¶æ€:', sessionId);

          // æ›´æ–°å½“å‰ä¼šè¯ä¸­æ‰€æœ‰è‡ªå·±å‘é€çš„æ¶ˆæ¯çŠ¶æ€ä¸ºå·²è¯»
          this.messages.forEach((msg, index) => {
            if (msg.isSelf && msg.sessionId == sessionId && msg.dbStatus !== newStatus) {
              msg.dbStatus = newStatus;
              this.$set(this.messages, index, { ...msg });
            }
          });

          console.log('âœ… æ‰¹é‡æ¶ˆæ¯çŠ¶æ€æ›´æ–°å®Œæˆ');
        }
        // å¦‚æœæ˜¯å•ä¸ªæ¶ˆæ¯å·²è¯»é€šçŸ¥
        else if (messageData.type === 'MESSAGE_READ') {
          const messageId = messageData.messageId;
          const newStatus = messageData.status;

          const messageIndex = this.messages.findIndex(msg => msg.id == messageId);
          if (messageIndex !== -1) {
            this.messages[messageIndex].dbStatus = newStatus;
            this.$set(this.messages, messageIndex, { ...this.messages[messageIndex] });
          }
        }
      },

      handleNewMessage(messageData) {
        console.log('å¤„ç†æ–°æ¶ˆæ¯æ•°æ®:', messageData);

        const newMessage = {
          id: messageData.id,
          sessionId: messageData.sessionId,
          fromUid: messageData.fromUid || messageData.fromUserId,
          toUid: messageData.toUid || messageData.toUserId,
          content: messageData.content,
          createTime: messageData.createTime || new Date().toISOString(),
          isSelf: (messageData.fromUid || messageData.fromUserId) === this.user.id,
          isSystem: false,
          status: 'sent',
          dbStatus: messageData.status // æ•°æ®åº“çŠ¶æ€ï¼ˆ1å·²è¯»ï¼Œ2å·²é€è¾¾ï¼‰
        };

        if (!this.messages.find(msg => msg.id === newMessage.id)) {
          this.messages.push(newMessage);
          this.scrollToBottom();
          console.log('âœ… æ–°æ¶ˆæ¯å·²æ·»åŠ åˆ°ç•Œé¢:', newMessage);
        }
      },

      handleMessageSent(messageData) {
        console.log('ğŸ”” æ¶ˆæ¯å‘é€æˆåŠŸå›è°ƒ:', messageData);
        const tempId = messageData.tempId;
        const messageId = messageData.messageId;

        console.log('ğŸ” å¯»æ‰¾ä¸´æ—¶æ¶ˆæ¯:', tempId);
        const messageIndex = this.messages.findIndex(msg => msg.tempId === tempId);

        if (messageIndex !== -1) {
          console.log('âœ… æ‰¾åˆ°ä¸´æ—¶æ¶ˆæ¯ï¼Œæ›´æ–°çŠ¶æ€');
          this.messages[messageIndex].id = messageId;
          this.messages[messageIndex].status = 'sent';
          this.messages[messageIndex].tempId = undefined;
          this.$set(this.messages, messageIndex, { ...this.messages[messageIndex] });
          console.log('âœ… ä¸´æ—¶æ¶ˆæ¯æ›´æ–°ä¸ºæ­£å¼æ¶ˆæ¯:', messageId);
        } else {
          console.log('âŒ æœªæ‰¾åˆ°å¯¹åº”çš„ä¸´æ—¶æ¶ˆæ¯ï¼ŒtempId:', tempId);
        }
      },

      handleSystemMessage(messageData) {
        this.messages.push({
          id: 'system_' + Date.now(),
          content: messageData.content,
          isSelf: false,
          isSystem: true,
          createTime: new Date().toISOString()
        });
        this.scrollToBottom();
      },

      getStatusText(status) {
        const statusMap = { 'sending': 'å‘é€ä¸­...', 'sent': 'å·²å‘é€', 'failed': 'å‘é€å¤±è´¥' };
        return statusMap[status] || '';
      },

      updateConnectionStatus(status, text, autoHide = null) {
        this.wsStatus = status;
        this.connectionStatusText = text;
        this.showConnectionStatus = true;
        if (autoHide && status === 'connected') {
          setTimeout(() => this.showConnectionStatus = false, autoHide);
        }
      },

      getToken() {
        const token = sessionStorage.getItem('token');
        return token;
      },

      showPageLoading(text = 'æ­£åœ¨åŠ è½½...') { this.pageLoading = true; this.loadingText = text; },
      hidePageLoading() { this.pageLoading = false; this.refreshLoading = false; },
      showRefreshLoading(text = 'æ­£åœ¨åˆ·æ–°...') { this.refreshLoading = true; this.loadingText = text; },

      handlePageRefresh() {
        if (this.firstLoad) {
          this.showPageLoading('æ­£åœ¨åŠ è½½èŠå¤©æ¶ˆæ¯...');
          this.firstLoad = false;
        } else {
          this.showRefreshLoading('æ­£åœ¨åˆ·æ–°...');
        }
      },

      async queryLoginUser() {
        try {
          const response = await axios.get("/app/user/me");
          this.user = response.data;
          if (this.user.icon) this.user.icon = fileURL + this.user.icon;
          console.log('ç”¨æˆ·ä¿¡æ¯:', this.user);

          // ç”¨æˆ·ä¿¡æ¯è·å–æˆåŠŸååˆå§‹åŒ– WebSocket
          this.initWebSocket();
          await this.loadChatMessagesWithLoading();

        } catch (error) {
          console.error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
          this.hidePageLoading();
          // å³ä½¿è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ä¹Ÿåˆå§‹åŒ–WebSocket
          this.initWebSocket();
        }
      },

      async loadChatMessagesWithLoading() {
        if (this.loading) return;
        this.loading = true;

        try {
          const response = await axios.get('/app/chat/message/list', { params: { sessionId: this.sessionId, current: 1 } });
          const newMessages = response.data || [];
          console.log('ä»APIåŠ è½½çš„æ¶ˆæ¯:', newMessages);

          if (newMessages.length === 0) {
            this.messages = [];
            this.noMore = true;
          } else {
            const processedMessages = newMessages.map(msg => ({
              ...msg,
              isSelf: msg.fromUid === this.user.id,
              isSystem: false,
              status: 'sent',
              dbStatus: msg.status // æ•°æ®åº“çŠ¶æ€
            }));

            this.messages = processedMessages;
            this.current = 1;
            this.noMore = false;
            this.scrollToBottom();
          }
        } catch (error) {
          console.error('åŠ è½½èŠå¤©æ¶ˆæ¯å¤±è´¥:', error);
          this.$message.error('åŠ è½½æ¶ˆæ¯å¤±è´¥');
        } finally {
          this.loading = false;
          this.hidePageLoading();
        }
      },

      async getChatSession() {
        try {
          const response = await axios.get('/app/chat/chatSession', { params: { sessionId: this.sessionId } });
          const sessionInfo = response.data;
          this.contactName = sessionInfo.contactName || 'æœªçŸ¥ç”¨æˆ·';
          this.contactAvatar = fileURL + (sessionInfo.contactAvatar || '');
          this.fromUid = sessionInfo.fromUid;
          this.toUid = sessionInfo.toUid;
          console.log('ä¼šè¯ä¿¡æ¯:', sessionInfo);
          await this.loadChatMessagesWithLoading();
        } catch (error) {
          console.error('è·å–ä¼šè¯ä¿¡æ¯å¤±è´¥:', error);
          this.$message.error('è·å–ä¼šè¯ä¿¡æ¯å¤±è´¥');
          this.hidePageLoading();
        }
      },

      getGroupTime(timeStr) {
        if (!timeStr) return '';
        try {
          const date = new Date(timeStr);
          return date.toLocaleDateString() + ' ' +
                  date.getHours().toString().padStart(2, '0') + ':' +
                  date.getMinutes().toString().padStart(2, '0');
        } catch (e) { return timeStr; }
      },

      formatGroupTime(groupTime) { return groupTime; },

      scrollToBottom() {
        this.$nextTick(() => {
          const container = this.$refs.chatMessages;
          if (container) {
            container.scrollTop = container.scrollHeight;
            this.isAtBottom = true;
          }
        });
      },

      async sendMessage() {
        if (this.isSendDisabled) {
          this.showDisabledReason();
          return;
        }

        const content = this.messageInput.trim();
        if (!content) {
          this.$message.warning('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹');
          return;
        }

        console.log('å¼€å§‹å‘é€æ¶ˆæ¯:', content);
        this.isSending = true;

        try {
          const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

          const tempMessage = {
            id: tempId,
            tempId: tempId,
            sessionId: this.sessionId,
            fromUid: this.user.id,
            toUid: this.toUid,
            content: content,
            createTime: new Date().toISOString(),
            isSelf: true,
            isSystem: false,
            status: 'sending'
          };

          console.log('åˆ›å»ºä¸´æ—¶æ¶ˆæ¯:', tempMessage);

          this.messages.push(tempMessage);
          this.messageInput = '';
          this.scrollToBottom();

          let sendResult = false;
          if (window.globalWsManager) {
            sendResult = window.globalWsManager.sendMessage('CHAT_MESSAGE', {
              toUserId: this.toUid,
              content: content,
              sessionId: this.sessionId,
              tempId: tempId
            });
            console.log('é€šè¿‡WebSocketå‘é€æ¶ˆæ¯ï¼Œç»“æœ:', sendResult);
          } else {
            console.log('âš ï¸ WebSocketæœªå°±ç»ªï¼Œä½¿ç”¨æ¨¡æ‹Ÿå‘é€');
            setTimeout(() => this.handleMessageSent({ tempId: tempId, messageId: Date.now() }), 500);
            sendResult = true;
          }

          if (!sendResult) {
            const messageIndex = this.messages.findIndex(msg => msg.tempId === tempId);
            if (messageIndex !== -1) {
              this.messages[messageIndex].status = 'failed';
              this.$set(this.messages, messageIndex, { ...this.messages[messageIndex] });
            }
            this.$message.error('å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥çŠ¶æ€');
          }

        } catch (error) {
          console.error('å‘é€æ¶ˆæ¯æ•è·åˆ°é”™è¯¯:', error);
          this.$message.error('å‘é€æ¶ˆæ¯å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'));
        } finally {
          this.isSending = false;
        }
      },

      showDisabledReason() {
        const reasons = [];
        if (!this.messageInput || this.messageInput.trim() === '') reasons.push('æ¶ˆæ¯å†…å®¹ä¸ºç©º');
        if (this.isSending) reasons.push('æ­£åœ¨å‘é€ä¸­');
        if (!this.forceEnableSend && !this.isWebSocketReady) reasons.push('WebSocketæœªå°±ç»ª');

        console.log('å‘é€æŒ‰é’®ç¦ç”¨åŸå› :', reasons);
        this.$message.warning(`å‘é€æŒ‰é’®ç¦ç”¨: ${reasons.join(', ')}`);
      },

      goBack() { location.href = "/chat-list.html"; },

      handleScroll() {
        const container = this.$refs.chatMessages;
        if (!container) return;

        const { scrollTop, scrollHeight, clientHeight } = container;
        this.isAtBottom = (scrollHeight - scrollTop - clientHeight) <= 50;

        if (scrollTop === 0 && !this.loading && !this.noMore) {
          this.loadMoreMessages();
        }
      },

      async loadMoreMessages() {
        if (this.loading || this.noMore) return;

        this.loading = true;
        const oldScrollHeight = this.$refs.chatMessages.scrollHeight;

        try {
          const nextPage = this.current + 1;
          const response = await axios.get('/app/chat/message/list', { params: { sessionId: this.sessionId, current: nextPage } });
          const newMessages = response.data || [];

          if (newMessages.length === 0) {
            this.noMore = true;
            return;
          }

          const processedMessages = newMessages.map(msg => ({
            ...msg,
            isSelf: msg.fromUid === this.user.id,
            isSystem: false,
            status: 'sent',
            dbStatus: msg.status // æ•°æ®åº“çŠ¶æ€
          }));

          this.messages = [...processedMessages, ...this.messages];
          this.current = nextPage;

          this.$nextTick(() => {
            const container = this.$refs.chatMessages;
            const newScrollHeight = container.scrollHeight;
            container.scrollTop = newScrollHeight - oldScrollHeight;
          });

        } catch (error) {
          console.error('åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥:', error);
        } finally {
          this.loading = false;
        }
      },

      refreshMessages() {
        this.messages = [];
        this.current = 1;
        this.noMore = false;
        this.loadChatMessagesWithLoading();
      },

      handleAvatarError(event) {
        event.target.style.display = 'none';
        const avatarElement = event.target.parentElement;
        const fallback = document.createElement('div');
        fallback.className = 'avatar-fallback';
        const displayName = event.target.alt || 'ç”¨æˆ·';
        fallback.textContent = displayName.charAt(0).toUpperCase();
        avatarElement.appendChild(fallback);
      }
    }
  });
</script>
</body>
</html>